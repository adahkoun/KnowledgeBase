Steps to learn Kubernetes :
    Familiarize yourself with the basics of containerization and Docker
    Gain an understanding of the core concepts of Kubernetes, such as pods, nodes, and services.
    Set up a local development environment for testing purposes.
    Practice deploying, scaling, and managing applications on a cluster.
    Learn how to use and apply Kubernetes manifests.
    Study Kubernetes networking and service discovery.
    Explore Kubernetes storage and volume management.
    Familiarize yourself with popular tools and extensions, such as kubectl and Helm.
    Read and experiment with example use-cases and real-world scenarios.
    Participate in the Kubernetes community by attending meetups and contributing to open-source projects.

What is Kubernetes :
    Kubernetes is an open-source platform for automating the deployment, scaling, and management of containerized applications. It uses a cluster of machines, with each machine running one or more containers, and a set of control plane components that orchestrate the deployment and management of these containers.
    Kubernetes is based on the concept of "pods" which are the smallest deployable units in the system. Pods contain one or more containers, and they share the same network and storage resources. Pods are created and managed by higher-level abstractions, such as "Replication Controllers" and "Services".
    Replication Controllers ensure that a specified number of replicas of a pod are running at any given time. If a pod fails, a Replication Controller will create a new one to replace it. Services provide a stable network endpoint for pods, allowing them to communicate with each other, and with external systems.
    The control plane components in Kubernetes, such as the API server, scheduler, and controller manager, communicate with each other to orchestrate the deployment, scaling, and management of pods. The API server is the central management component, responsible for storing the desired state of the system, and serving this state to other components. The scheduler is responsible for deciding which nodes in the cluster should run a given pod. The controller manager is responsible for reconciling the actual state of the system with the desired state, and making necessary changes to bring them into alignment.
    Kubernetes provides various tools for networking, such as "network plugins" that allow pods to communicate with each other, and "ingress controllers" that manage inbound network traffic to the cluster. It also provides features for storage management, such as "persistent volumes" and "volume plugins", which allow pods to access and store data.
    In terms of security, Kubernetes provides authentication and authorization mechanisms, as well as tools for network segmentation, such as network policies. It also provides features for securing sensitive data, such as secrets and certificates, which can be stored in a secure manner and accessed by pods as needed.
    Kubernetes also offers extensibility through the use of "custom resources" and "operators", allowing users to extend its capabilities and integrate with other systems.
    Overall, Kubernetes provides a powerful platform for deploying and managing containerized applications, with a rich set of features for networking, storage, security, and extensibility.
    
Kubernetes Architecture :
    Kubernetes architecture consists of a cluster of nodes, a set of control plane components, and a distributed storage system.
    Nodes: The nodes in the cluster are the machines that run the containers. They can be physical machines or virtual machines running in a cloud environment. Each node runs a container runtime, such as Docker, to manage containers, and an agent called the "kubelet", which communicates with the control plane components.
    Control Plane: The control plane components are responsible for the orchestration of the deployment, scaling, and management of containers. The main components of the control plane are:
    API Server: The API server is the central management component, responsible for storing the desired state of the system, and serving this state to other components. It implements the Kubernetes API and serves as the single source of truth for the state of the system.
    Scheduler: The scheduler is responsible for deciding which nodes in the cluster should run a given pod. It takes into account factors such as resource utilization, constraints, and node availability, to determine the best node for a pod to run on.
    Controller Manager: The controller manager is responsible for reconciling the actual state of the system with the desired state, and making necessary changes to bring them into alignment. It implements a number of controllers, such as the Replication Controller, which ensures that a specified number of replicas of a pod are running at any given time.
    etcd: etcd is a distributed key-value store that serves as the backing store for the state of the system. The API server stores the desired state of the system in etcd, and other components, such as the scheduler and controller manager, read from etcd to determine the current state of the system.
    Distributed Storage: Kubernetes provides various tools for storage management, such as "persistent volumes" and "volume plugins". Persistent volumes allow pods to access and store data, and they can be dynamically provisioned by the system. Volume plugins allow different types of storage, such as network-attached storage or cloud-based storage, to be used with Kubernetes.
    In summary, the Kubernetes architecture consists of a cluster of nodes, a set of control plane components, and a distributed storage system, working together to provide a platform for deploying and managing containerized applications.
    
Kubernetes Components :
    API server: The central component that exposes the Kubernetes API and serves as the primary endpoint for administrative tasks and operations.
    etcd: A distributed key-value store used to persist the configuration data for the cluster.
    kube-controller-manager: A component that runs various controllers that are responsible for maintaining the state of the cluster, such as the replication controller, endpoint controller, and namespace controller.
    kube-scheduler: A component that assigns pods to nodes based on resource requirements and constraints.
    kubelet: An agent that runs on each node and communicates with the API server to ensure that containers are running as expected.
    kubectl: The command-line tool used to manage and interact with a Kubernetes cluster.
    kube-proxy: A component that runs on each node and implements the network routing for pods, allowing them to communicate with other pods and services in the cluster.
    Container runtime: The software responsible for launching and managing containers, such as Docker, CRI-O, or containerd.
    kubeadm: A tool for bootstrapping a minimal Kubernetes cluster, which can be used to deploy a simple, single-node cluster for testing or development purposes.
    CoreDNS: A DNS server used for service discovery and name resolution within a cluster.
    CNI (Container Network Interface): A plugin-based architecture used to provide network connectivity to containers within a cluster.
    Volume plugins: Components that provide persistent storage for containers, such as NFS, GlusterFS, or Ceph.
    Kubernetes Dashboard: A web-based graphical interface for managing and monitoring a Kubernetes cluster.
    StatefulSets: A resource for managing stateful applications in a cluster, providing guarantees about the ordering and uniqueness of pods.
    DaemonSets: A resource for running a single instance of a pod on each node in the cluster, which is useful for running system-level services such as log collection agents or node-level network proxies.
    Jobs and CronJobs: Resources for running one-time or recurring batch jobs in a cluster, such as data processing or backups.
    ConfigMaps and Secrets: Resources for storing configuration data and sensitive information, respectively, that can be consumed by pods and applications.
    Ingress Controllers: Components that manage incoming HTTP and HTTPS traffic to a cluster and route it to the appropriate service.
    Service Mesh: A set of tools and APIs for managing network communication between microservices within a cluster.
    Certificate Management: Components that manage and rotate TLS certificates for secure communication within a cluster.
    Horizontal Pod Autoscaler: A component that automatically adjusts the number of replicas of a pod based on resource utilization metrics.
    Custom Resource Definitions (CRDs): A mechanism for extending the Kubernetes API with custom resources, allowing users to define and manage their own custom resource types.
    Cluster-level Logging and Monitoring: Components for collecting, aggregating, and analyzing log data and system metrics for a cluster.
    Federation: A mechanism for managing multiple, disparate clusters as a single, unified cluster, enabling cross-cluster operations and scaling.
    
Kubernetes Resources :
    Pod: The smallest and simplest unit in the Kubernetes object model, representing a single process in a cluster. Pods contain one or more containers and shared storage, networking, and metadata.
    ReplicationController: A resource responsible for ensuring that a specified number of replicas of a pod are running at any given time. If there are too few replicas, the ReplicationController will start new pods, and if there are too many, it will kill some.
    ReplicaSet: A resource similar to ReplicationController, but with more powerful selector capabilities, allowing for finer-grained control over which pods are considered part of a ReplicaSet.
    Deployment: A resource for declaratively managing the desired state of a set of replicas, using ReplicaSets to ensure that the specified number of replicas are running. Deployments allow for easy rollouts and rollbacks of new versions of an application.
    StatefulSet: A resource for managing stateful applications, providing stable hostnames and persistent storage to pods, as well as ordered, graceful deployment and scaling.
    DaemonSet: A resource for ensuring that a copy of a pod runs on all (or some) of the nodes in a cluster. DaemonSets are used for tasks such as running a cluster-level log collection agent.
    Job: A resource for running batch jobs, typically used for executing one-off tasks or running parallel workloads.
    CronJob: A resource for scheduling recurring jobs using a cron-like syntax.
    Service: A resource for providing a stable IP address and DNS name for a set of pods, as well as load balancing incoming requests between pods.
    ConfigMap: A resource for storing configuration data, separate from application code and configurable in real-time.
    Secret: A resource for storing sensitive information, such as passwords, tokens, or keys, encrypted at rest.
    PersistentVolume: A resource for describing an existing piece of network-attached storage in a cluster, typically provided by a cloud provider.
    PersistentVolumeClaim: A resource for requesting a piece of storage from the cluster, dynamically provisioned from PersistentVolumes if necessary.
    StorageClass: A resource for describing the properties of a piece of storage, such as performance, durability, or accessibility, used to dynamically provision PersistentVolumes.
    HorizontalPodAutoscaler: A resource for automatically adjusting the number of replicas of a deployment based on observed CPU utilization or other custom metrics.
    Ingress: A resource for exposing services to the external network, typically used to load balance incoming HTTP or HTTPS traffic.
    Namespace: A resource for organizing and dividing a cluster into multiple virtual clusters, each with its own resources, networks, and users.
    Role: A resource for granting a set of permissions to a set of users within a single namespace.
    RoleBinding: A resource for binding a Role to a set of users within a single namespace.
    ClusterRole: A resource for granting a set of permissions to a set of users cluster-wide.
    ClusterRoleBinding: A resource for binding a ClusterRole to a set of users cluster-wide.
    Endpoints: A resource for representing network endpoints, typically used to describe the network locations of pods in a service.
    Event
    ResourceQuota
    LimitRange
    Volume
    VolumeClaim
    PersistentVolumeClaimTemplates
    Scheduling
    PriorityClass
    Taints and Tolerations
    PodPreset
 
